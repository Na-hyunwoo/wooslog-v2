name: Build and Deploy Next.js App

on:
  push:
    branches:
      - main

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: na-hyunwoo/wooslog-v2/main
  IMAGE_TAG: ${{ github.sha }}

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Setup PNPM
        uses: pnpm/action-setup@v2
        with:
          version: 8

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: 20
          cache: "pnpm"

      - name: Install dependencies
        run: pnpm install

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Log in to the Container registry
        uses: docker/login-action@v2
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@v4
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=sha,format=long
            type=ref,event=branch
            latest

      - name: Build and push Docker image
        uses: docker/build-push-action@v4
        with:
          context: .
          file: ./apps/main/dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            NOTION_API_KEY=${{ secrets.NOTION_API_KEY }}
            NEXT_PUBLIC_SUPABASE_URL=${{ secrets.NEXT_PUBLIC_SUPABASE_URL }}
            NEXT_PUBLIC_SUPABASE_ANON_KEY=${{ secrets.NEXT_PUBLIC_SUPABASE_ANON_KEY }}

      - name: Deploy to server
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USERNAME }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            # 최신 이미지 가져오기
            docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest

            # 필요한 디렉토리 생성
            mkdir -p ~/nginx/conf.d ~/certbot/conf ~/certbot/www ~/logs

            # nginx 기본 설정 파일 생성
            cat > ~/nginx/nginx.conf << 'EOL'
            user nginx;
            worker_processes auto;

            error_log /var/log/nginx/error.log warn;
            pid /var/run/nginx.pid;

            events {
                worker_connections 1024;
            }

            http {
                include /etc/nginx/mime.types;
                default_type application/octet-stream;
                
                log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                              '$status $body_bytes_sent "$http_referer" '
                              '"$http_user_agent" "$http_x_forwarded_for"';
                
                access_log /var/log/nginx/access.log main;
                
                sendfile on;
                keepalive_timeout 65;
                
                include /etc/nginx/conf.d/*.conf;
            }
            EOL

            # nginx 앱 설정 파일 생성 (HTTP와 HTTPS 설정)
            cat > ~/nginx/conf.d/app.conf << 'EOL'
            server {
                listen 80;
                server_name devna.xyz www.devna.xyz;
                
                location /.well-known/acme-challenge/ {
                    root /var/www/certbot;
                }
                
                location / {
                    return 301 https://$host$request_uri;
                }
            }

            server {
                listen 443 ssl;
                server_name devna.xyz www.devna.xyz;
                
                ssl_certificate /etc/letsencrypt/live/devna.xyz/fullchain.pem;
                ssl_certificate_key /etc/letsencrypt/live/devna.xyz/privkey.pem;
                
                include /etc/letsencrypt/options-ssl-nginx.conf;
                ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem;
                
                location / {
                    proxy_pass http://main-app:3000;
                    proxy_set_header Host $host;
                    proxy_set_header X-Real-IP $remote_addr;
                    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                    proxy_set_header X-Forwarded-Proto $scheme;
                }
            }
            EOL

            # SSL 옵션 파일 생성
            mkdir -p ~/certbot/conf/
            cat > ~/certbot/conf/options-ssl-nginx.conf << 'EOL'
            ssl_session_cache shared:le_nginx_SSL:10m;
            ssl_session_timeout 1440m;
            ssl_session_tickets off;
            ssl_protocols TLSv1.2 TLSv1.3;
            ssl_prefer_server_ciphers off;
            ssl_ciphers "ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384";
            EOL

            # SSL DH 파라미터 파일 생성
            cat > ~/certbot/conf/ssl-dhparams.pem << 'EOL'
            -----BEGIN DH PARAMETERS-----
            MIIBCAKCAQEA//////////+t+FRYortKmq/cViAnPTzx2LnFg84tNpWp4TZBFGQz
            +8yTnc4kmz75fS/jY2MMddj2gbICrsRhetPfHtXV/WVhJDP1H18GbtCFY2VVPe0a
            87VXE15/V8k1mE8McODmi3fipona8+/och3xWKE2rec1MKzKT0g6eXq8CrGCsyT7
            YdEIqUuyyOP7uWrat2DX9GgdT0Kj3jlN9K5W7edjcrsZCwenyO4KbXCeAvzhzffi
            7MA0BM0oNC9hkXL+nOmFg/+OTxIy7vKBg8P+OxtMb61zO7X8vC7CIAXFjvGDfRaD
            ssbzSibBsu/6iGtCOGEoXJf//////////wIBAg==
            -----END DH PARAMETERS-----
            EOL

            # docker-compose 파일 생성
            cat > ~/docker-compose.yml << 'EOL'
            version: '3'

            services:
              main-app:
                image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
                restart: always
                ports:
                  - "3000:3000"
                environment:
                  - NODE_ENV=production
                  - NOTION_API_KEY=${{ secrets.NOTION_API_KEY }}
                  - NEXT_PUBLIC_SUPABASE_URL=${{ secrets.NEXT_PUBLIC_SUPABASE_URL }}
                  - NEXT_PUBLIC_SUPABASE_ANON_KEY=${{ secrets.NEXT_PUBLIC_SUPABASE_ANON_KEY }}
                volumes:
                  - app-data:/app/data
                  - ./logs:/app/logs
                networks:
                  - app-network
                healthcheck:
                  test: ["CMD", "curl", "-f", "http://localhost:3000"]
                  interval: 30s
                  timeout: 10s
                  retries: 3
                  start_period: 40s
                deploy:
                  resources:
                    limits:
                      cpus: '0.5'
                      memory: 512M

              nginx: 
                image: nginx:alpine
                container_name: nginx-proxy
                restart: always
                ports:
                  - "80:80"
                  - "443:443"
                volumes:
                  - ./nginx/conf.d:/etc/nginx/conf.d
                  - ./nginx/nginx.conf:/etc/nginx/nginx.conf
                  - ./certbot/conf:/etc/letsencrypt
                  - ./certbot/www:/var/www/certbot
                depends_on:
                  - main-app
                networks:
                  - app-network
                command: "/bin/sh -c 'while :; do sleep 6h & wait $${!}; nginx -s reload; done & nginx -g \"daemon off;\"'"

              certbot:
                image: certbot/certbot
                container_name: certbot
                volumes:
                  - ./certbot/conf:/etc/letsencrypt
                  - ./certbot/www:/var/www/certbot
                networks:
                  - app-network
                entrypoint: "/bin/sh -c 'trap exit TERM; while :; do certbot renew; sleep 12h & wait $${!}; done;'"

            networks:
              app-network:
                driver: bridge

            volumes:
              app-data:
                driver: local
            EOL

            # 최초 인증서 발급 스크립트 생성
            cat > ~/init-letsencrypt.sh << 'EOL'
            #!/bin/bash

            domains=(devna.xyz www.devna.xyz)
            email="contactharry97@gmail.com"  
            staging=0

            data_path="./certbot"
            rsa_key_size=4096

            if [ -d "$data_path/conf/live" ]; then
              read -p "기존 인증서 데이터가 발견되었습니다. 계속하시겠습니까? (y/N) " decision
              if [ "$decision" != "Y" ] && [ "$decision" != "y" ]; then
                exit
              fi
            fi

            mkdir -p "$data_path/conf/live"

            echo "Nginx 실행 중지..."
            docker-compose down

            echo "도메인 설정 다운로드 중..."
            curl -s https://raw.githubusercontent.com/certbot/certbot/master/certbot-nginx/certbot_nginx/_internal/tls_configs/options-ssl-nginx.conf > "$data_path/conf/options-ssl-nginx.conf"
            curl -s https://raw.githubusercontent.com/certbot/certbot/master/certbot/certbot/ssl-dhparams.pem > "$data_path/conf/ssl-dhparams.pem"

            echo "더미 인증서 생성 중..."
            for domain in "${domains[@]}"; do
              mkdir -p "$data_path/conf/live/$domain"
              
              openssl req -x509 -nodes -newkey rsa:$rsa_key_size -days 1 \
                -keyout "$data_path/conf/live/$domain/privkey.pem" \
                -out "$data_path/conf/live/$domain/fullchain.pem" \
                -subj "/CN=localhost"
            done

            echo "Docker 컨테이너 시작 중..."
            docker-compose up -d nginx

            echo "인증서 발급 중..."
            for domain in "${domains[@]}"; do
              docker-compose run --rm --entrypoint "\
                certbot certonly --webroot -w /var/www/certbot \
                  --email $email \
                  -d $domain \
                  --rsa-key-size $rsa_key_size \
                  --agree-tos \
                  --force-renewal \
                  --non-interactive" certbot
            done

            echo "Docker 컨테이너 재시작 중..."
            docker-compose down
            docker-compose up -d

            echo "완료!"
            EOL

            # 스크립트 실행 권한 부여
            chmod +x ~/init-letsencrypt.sh

            # 배포 실행
            cd ~
            docker-compose down
            ./init-letsencrypt.sh
            docker-compose up -d

            # 미사용 이미지 정리
            docker image prune -af
